/**
 * Copyright 2018-2021 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _CORE_CACHING_IBEACONCACHE_H
#define _CORE_CACHING_IBEACONCACHE_H

#include "BeaconKey.h"
#include "IObserver.h"
#include "core/UTF8String.h"

#include <cstdint>
#include <memory>
#include <unordered_set>

namespace core
{
	namespace caching
	{
		///
		/// Beacon Cache used to cache the Beacons generated by all sessions, actions, ...
		///
		class IBeaconCache
		{
		public:

			///
			/// Destructor
			///
			virtual ~IBeaconCache() = default;

			///
			/// Add an @c IObserver which gets notified after a new event data or action data got inserted.
			/// @param[in] observer
			///
			virtual void addObserver(IObserver* observer) = 0;

			///
			/// Add event data for a given BeaconKey to this cache.
			///
			/// All registered observers are notified, after the event data has been added.
			///
			/// @param[in] beaconKey The beacon's key for which to add event data.
			/// @param[in] timestamp The data's timestamp.
			/// @param[in] data serialized event data to add.
			///
			virtual void addEventData(const BeaconKey& beaconKey, int64_t timestamp, const core::UTF8String& data) = 0;

			///
			/// Add action data for a given BeaconKey to this cache.
			///
			/// @param[in] beaconKey The beacon's key for which to add action data.
			/// @param[in] timestamp The data's timestamp.
			/// @param[in] data serialized action data to add.
			///
			virtual void addActionData(const BeaconKey& beaconKey, int64_t timestamp, const core::UTF8String& data) = 0;

			///
			/// Delete a cache entry for a given BeaconKey.
			/// 
			/// @param[in] beaconKey The beacon's key which to delete.
			///
			virtual void deleteCacheEntry(const BeaconKey& beaconKey) = 0;

			///
            /// Prepare all data, that has been recorded so far, for sending.
            ///
            /// Note: This method must only be invoked from the beacon sending thread.
            ///
            /// @param beaconKey[in] The beacon key for which to copy the collected data.
			///
			virtual void prepareDataForSending(const BeaconKey& beaconKey) = 0;

			///
			/// Test if there is more data to send.
			///
			/// @param beaconKey[in] key The beaconkey for which to check if there is more data for sending.
			/// @retval true if there is data for sending
			/// @retval if BeaconKey does not exist or there is no data for sending.
			///
			virtual bool hasDataForSending(const BeaconKey& beaconKey) = 0;

			///
			/// Get the next chunk for sending to the backend.
			///
			/// Note: This method must only be invoked from the beacon sending thread.
			///
			/// @param[in] beaconKey The beacon key for which to get the next chunk.
			/// @param[in] chunkPrefix Prefix to append to the beginning of the chunk.
			/// @param[in] maxSize Maximum chunk size. As soon as chunk's size is greater than or equal to maxSize result is returned.
			/// @param[in] delimiter Delimiter between consecutive chunks.
			/// @return the next chunk to send or an empty string, if either the given @c beaconID does not exist or if there is no more data to send.
			///
			virtual const core::UTF8String getNextBeaconChunk(const BeaconKey& beaconKey, const core::UTF8String& chunkPrefix, int32_t maxSize, const core::UTF8String& delimiter) = 0;

			///
			/// Remove all data that was previously included in chunks.
			///
			/// This method must be called, when data retrieved via @ref getNextBeaconChunk was successfully sent to the backend,
			/// otherwise subsequent calls to @ref getNextBeaconChunk will retrieve the same data again and again.
			///
			/// Note: This method must only be invoked from the beacon sending thread.
			///
			/// @param[in] beaconKey The beacon key for which to remove already chunked data.
			///
			virtual void removeChunkedData(const BeaconKey& beaconKey) = 0;

			///
			/// Reset all data that was previously included in chunks.
			///
			/// Note: This method must only be invoked from the beacon sending thread.
			///
			/// @param[in] beaconKey The beacon key for which to reset already chunked data.
			///
			virtual void resetChunkedData(const BeaconKey& beaconKey) = 0;

			///
			/// Get an std::unordered_set of currently inserted Beacon keys.
			///
			/// The return value is a snapshot of currently inserted beacon keys.
			/// All changes made after this call are not reflected in the returned Set.
			///
			/// @return Snapshot of all beacon keys in the cache.
			///
			virtual const std::unordered_set<BeaconKey, BeaconKey::Hash> getBeaconKeys() = 0;

			///
			/// Evict @ref BeaconCacheRecord by age for a given beacon.
			///
			/// @param[in] beaconKey      The beacon's key.
			/// @param[in] minTimestamp  The minimum timestamp allowed.
			/// @return Returns the number of evicted cache records.
			///
			virtual uint32_t evictRecordsByAge(const BeaconKey& beaconKey, int64_t minTimestamp) = 0;

			///
			/// Evict @ref BeaconCacheRecord by number for given beacon.
			///
			/// @param[in] beaconKey   The beacon's identifier.
			/// @param[in] numRecords The maximum number of records to evict.
			/// @return Returns the number of evicted cache records.
			///
			virtual uint32_t evictRecordsByNumber(const BeaconKey & beaconKey, uint32_t numRecords) = 0;

			///
			/// Get number of bytes currently stored in cache.
			///
			/// @return Number of bytes currently stored in cache.
			///
			virtual int64_t getNumBytesInCache() const = 0;

			///
			/// Tests if an cached entry for given BeaconKey is empty.
			///
			/// @param[in] beaconKey The beacon's key.
			/// @return @c true if the cached entry is empty, @c false otherwise.
			///
			virtual bool isEmpty(const BeaconKey& beaconKey) = 0;
		};
	}
}

#endif
